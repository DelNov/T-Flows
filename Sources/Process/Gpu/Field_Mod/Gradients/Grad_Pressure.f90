!==============================================================================!
!   DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED FROM ITS FPP ORIGIN   !
!==============================================================================!

!==============================================================================!
  subroutine Grad_Pressure(Flow, Grid, phi)
!------------------------------------------------------------------------------!
  implicit none
!---------------------------------[Arguments]----------------------------------!
  class(Field_Type), target, intent(inout) :: Flow  !! parent flow object
  type(Grid_Type),           intent(in)    :: Grid  !! grid object
  type(Var_Type),    target                :: phi   !! pressure (correction)
!-----------------------------------[Locals]-----------------------------------!
  integer :: c, c1, c2, iter, s, reg
  real    :: dx, dy, dz
!==============================================================================!

  call Profiler % Start('Grad_Pressure')

  ! Store the name of the variable whose gradients you are computing
  Flow % stores_gradients_of = phi % name

  !----------------------------------!
  !   Nullify arrays on the device   !
  !----------------------------------!

  !$acc parallel loop independent  &
  !$acc present(  &
  !$acc   grid_region_f_cell,  &
  !$acc   grid_region_l_cell,  &
  !$acc   flow_phi_x,  &
  !$acc   flow_phi_y,  &
  !$acc   flow_phi_z   &
  !$acc )
  do c = grid_region_f_cell(1), grid_region_l_cell(grid_n_regions+1)  ! all present
    flow_phi_x(c) = 0.0
    flow_phi_y(c) = 0.0
    flow_phi_z(c) = 0.0
  end do
  !$acc end parallel

  !------------------------------------!
  !                                    !
  !   Iterativelly improve gradients   !
  !                                    !
  !------------------------------------!
  do iter = 1, Flow % least_miter

    !--------------------------------------!
    !   Extrapolate values to boundaries   !
    !--------------------------------------!
    do reg = Boundary_Regions()

      if(Grid % region % type(reg) .ne. PRESSURE) then

        phi_n => phi % n
        !$acc parallel loop  &
        !$acc present(  &
        !$acc   grid_region_f_face,  &
        !$acc   grid_region_l_face,  &
        !$acc   grid_faces_c,  &
        !$acc   phi_n,  &
        !$acc   flow_phi_x,  &
        !$acc   grid_dx,  &
        !$acc   flow_phi_y,  &
        !$acc   grid_dy,  &
        !$acc   flow_phi_z,  &
        !$acc   grid_dz   &
        !$acc )
        do s = grid_region_f_face(reg), grid_region_l_face(reg)
          c1 = grid_faces_c(1,s)
          c2 = grid_faces_c(2,s)

          phi_n(c2) = phi_n(c1) + flow_phi_x(c1) * grid_dx(s)  &
                                    + flow_phi_y(c1) * grid_dy(s)  &
                                    + flow_phi_z(c1) * grid_dz(s)
        end do
        !$acc end parallel

      else

        phi_n => phi % n
        !$acc parallel loop  &
        !$acc present(  &
        !$acc   grid_region_f_face,  &
        !$acc   grid_region_l_face,  &
        !$acc   grid_faces_c,  &
        !$acc   phi_n   &
        !$acc )
        do s = grid_region_f_face(reg), grid_region_l_face(reg)
          c2 = grid_faces_c(2,s)
          phi_n(c2) = 0.0
        end do
        !$acc end parallel

      end if  ! pressure or not

    end do    ! regions

    !---------------------------------------------------------------!
    !   Compute pressure gradients again with extrapolated values   !
    !---------------------------------------------------------------!
    call Flow % Grad_Component(Grid, phi % n, 1,  &
                               Flow % phi_x, boundary_updated=.true.)
    call Flow % Grad_Component(Grid, phi % n, 2,  &
                               Flow % phi_y, boundary_updated=.true.)
    call Flow % Grad_Component(Grid, phi % n, 3,  &
                               Flow % phi_z, boundary_updated=.true.)

  end do

  call Profiler % Stop('Grad_Pressure')

  end subroutine
