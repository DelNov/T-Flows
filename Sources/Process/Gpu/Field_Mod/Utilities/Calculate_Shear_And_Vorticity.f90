!==============================================================================!
!   DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED FROM ITS FPP ORIGIN   !
!==============================================================================!

!==============================================================================!
  subroutine Calculate_Shear_And_Vorticity(Flow, Grid)
!------------------------------------------------------------------------------!
!   Computes the magnitude of the Flow % shear stress.                         !
!------------------------------------------------------------------------------!
!   Shear of the velocity vield is a tensor define as:                         !
!                                                                              !
!   s_ij  = 1/2 ( dui/dxj + duj/dxi )                                          !
!                                                                              !
!   Shear's magnitude is computed as:                                          !
!                                                                              !
!   Flow % shear = sqrt( 2 * s_ij * s_ij )                                     !
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - !
!   Rotation of a velocity field is defined as:                                !
!                                                                              !
!         1         1                                                          !
!   rot = - ∇ x u = - ((dw/dy-dv/dz) i + (du/dz-dw/dx) j + (dv/dx-du/dy) k)    !
!         2         2                                                          !
!                                                                              !
!   Vorticity is twice the rotation vector, hence                              !
!                                                                              !
!                                                                              !
!   Flow % vort = ∇ x u = (dw/dy-dv/dz) i + (du/dz-dw/dx) j + (dv/dx-du/dy) k  !
!                                                                              !
!                = v_x i + v_y j + v_z k                                       !
!                                                                              !
!   Vorticity magnitude would be the magnitude of Flow % vorticity vector      !
!                                                                              !
!   |Flow % vort| = sqrt(v_x^2 + v_y^2 + v_z^2)                                !
!------------------------------------------------------------------------------!
  implicit none
!---------------------------------[Arguments]----------------------------------!
  class(Field_Type), target :: Flow
  type(Grid_Type),   target :: Grid  !! grid object is need for GPU
!-----------------------------------[Locals]-----------------------------------!
  real, contiguous, pointer :: u_x(:), u_y(:), u_z(:),  &
                               v_x(:), v_y(:), v_z(:),  &
                               w_x(:), w_y(:), w_z(:)
  integer                   :: c, c1, c2, s, reg, run
!==============================================================================!

  !----------------------------------------!
  !   Copy values to symmetry boundaries   !
  !   (Probably not the most consistent)   !
  !----------------------------------------!
  do reg = Boundary_Regions()
    if(Grid % region % type(reg) .eq. SYMMETRY) then

      !$acc parallel loop  &
      !$acc present(  &
      !$acc   grid_region_f_face,  &
      !$acc   grid_region_l_face,  &
      !$acc   grid_faces_c,  &
      !$acc   flow_u_n,  &
      !$acc   flow_v_n,  &
      !$acc   flow_w_n   &
      !$acc )
      do s = grid_region_f_face(reg), grid_region_l_face(reg)  ! all present
        c1 = grid_faces_c(1,s)   ! inside cell
        c2 = grid_faces_c(2,s)   ! boundary cell
        flow_u_n(c2) = flow_u_n(c1)
        flow_v_n(c2) = flow_v_n(c1)
        flow_w_n(c2) = flow_w_n(c1)
      end do
      !$acc end parallel

    end if
  end do

  !----------------------------------------!
  !   Compute Flow % shear in three runs   !
  !----------------------------------------!
  do run = 1, 3

    !---------------------------!
    !   Run #1: u_x, w_y, v_z   !
    !---------------------------!
    if(run .eq. 1) then
      u_x => Flow % phi_x
      w_y => Flow % phi_y
      v_z => Flow % phi_z
      call Flow % Grad_Component(Grid, Flow % u % n, 1, u_x)
      call Flow % Grad_Component(Grid, Flow % w % n, 2, w_y)
      call Flow % Grad_Component(Grid, Flow % v % n, 3, v_z)

      !$acc parallel loop independent  &
      !$acc present(  &
      !$acc   grid_region_f_cell,  &
      !$acc   grid_region_l_cell,  &
      !$acc   flow_shear,  &
      !$acc   u_x,  &
      !$acc   v_z,  &
      !$acc   w_y   &
      !$acc )
      do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present
        flow_shear(c) = u_x(c)**2 + .5 * (v_z(c)+w_y(c))**2
        Flow % vort (c) =           - .5 * (v_z(c)-w_y(c))**2
      end do
      !$acc end parallel

    !---------------------------!
    !   Run #2: w_x, v_y, u_z   !
    !---------------------------!
    else if(run .eq. 2) then
      w_x => Flow % phi_x
      v_y => Flow % phi_y
      u_z => Flow % phi_z
      call Flow % Grad_Component(Grid, Flow % w % n, 1, w_x)
      call Flow % Grad_Component(Grid, Flow % v % n, 2, v_y)
      call Flow % Grad_Component(Grid, Flow % u % n, 3, u_z)

      !$acc parallel loop independent  &
      !$acc present(  &
      !$acc   grid_region_f_cell,  &
      !$acc   grid_region_l_cell,  &
      !$acc   flow_shear,  &
      !$acc   v_y,  &
      !$acc   u_z,  &
      !$acc   w_x   &
      !$acc )
      do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present
        flow_shear(c) = flow_shear(c) + v_y(c)**2 + .5 * (u_z(c)+w_x(c))**2
        Flow % vort (c) = Flow % vort (c)             - .5 * (u_z(c)-w_x(c))**2
      end do
      !$acc end parallel

    !---------------------------!
    !   Run #3: v_x, u_y, w_z   !
    !---------------------------!
    else if(run .eq. 3) then
      v_x => Flow % phi_x
      u_y => Flow % phi_y
      w_z => Flow % phi_z
      call Flow % Grad_Component(Grid, Flow % v % n, 1, v_x)
      call Flow % Grad_Component(Grid, Flow % u % n, 2, u_y)
      call Flow % Grad_Component(Grid, Flow % w % n, 3, w_z)

      !$acc parallel loop independent  &
      !$acc present(  &
      !$acc   grid_region_f_cell,  &
      !$acc   grid_region_l_cell,  &
      !$acc   flow_shear,  &
      !$acc   w_z,  &
      !$acc   v_x,  &
      !$acc   u_y   &
      !$acc )
      do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present
        flow_shear(c) = flow_shear(c) + w_z(c)**2 + .5 * (v_x(c)+u_y(c))**2
        Flow % vort (c) = Flow % vort (c)             - .5 * (v_x(c)-u_y(c))**2
      end do
      !$acc end parallel

    end if

  end do

  !$acc parallel loop independent  &
  !$acc present(  &
  !$acc   grid_region_f_cell,  &
  !$acc   grid_region_l_cell,  &
  !$acc   flow_shear,  &
  !$acc   flow_vort   &
  !$acc )
  do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present
    flow_shear(c) = sqrt(2.0 * flow_shear(c))
    flow_vort (c) = sqrt(2.0 * abs(flow_vort(c)))
  end do
  !$acc end parallel


# if T_FLOWS_DEBUG == 1
    call Grid % Save_Debug_Vtu("shear",                  &
                               scalar_name="shear"    ,  &
                               scalar_cell=Flow % shear)
    call Grid % Save_Debug_Vtu("vorticity",              &
                               scalar_name="vorticity",  &
                               scalar_cell=Flow % vort)
# endif

  end subroutine
