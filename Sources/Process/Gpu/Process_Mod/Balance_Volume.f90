!==============================================================================!
!   DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED FROM ITS FPP ORIGIN   !
!==============================================================================!

!==============================================================================!
  subroutine Balance_Volume(Process, Flow, Grid)
!------------------------------------------------------------------------------!
!>  First part of inserting volume source for pressure-Poisson equation
!------------------------------------------------------------------------------!
  implicit none
!------------------------------------------------------------------------------!
  class(Process_Type)      :: Process
  type(Field_Type), target :: Flow
  type(Grid_Type),  target :: Grid
!-----------------------------------[Locals]-----------------------------------!
  real, contiguous, pointer :: b(:)
  real                      :: vol_in, vol_out, area_in, area_out, fac
  integer                   :: s, c2, c, reg
!------------------------[Avoid unused parent warning]-------------------------!
  Unused(Process)
!==============================================================================!

  call Profiler % Start('Balance_Volume')

  ! Take some aliases
  ! GPU version doesn't work if you use directly Flow % whatever_variable
  ! These aliases are really needed, not just some gimmick to shorten the code
  b => Flow % Nat % b

  ! Check if you have pressure gradients at hand and then set aliases properly
  Assert(Flow % stores_gradients_of .eq. 'P')

  ! Nullify the volume source
  !$acc parallel loop independent  &
  !$acc present(  &
  !$acc   grid_region_f_cell,  &
  !$acc   grid_region_l_cell,  &
  !$acc   b   &
  !$acc )
  do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions+1)  ! all present
    b(c) = 0.0
  end do
  !$acc end parallel

  !------------------------------------------!
  !                                          !
  !   Calculate / update volume flow rates   !
  !                                          !
  !------------------------------------------!

  !----------------------------------------------------!
  !   Calculate volume fluxes through boundary faces   !
  !----------------------------------------------------!
  do reg = Boundary_Regions()

    if(Grid % region % type(reg) .eq. SYMMETRY) then
      !$acc parallel loop  &
      !$acc present(  &
      !$acc   grid_region_f_face,  &
      !$acc   grid_region_l_face,  &
      !$acc   flow_v_flux_n   &
      !$acc )
      do s = grid_region_f_face(reg), grid_region_l_face(reg)
        flow_v_flux_n(s) = 0.0
      end do
      !$acc end parallel
    else
      !$acc parallel loop  &
      !$acc present(  &
      !$acc   grid_region_f_face,  &
      !$acc   grid_region_l_face,  &
      !$acc   grid_faces_c,  &
      !$acc   flow_v_flux_n,  &
      !$acc   flow_u_n,  &
      !$acc   grid_sx,  &
      !$acc   flow_v_n,  &
      !$acc   grid_sy,  &
      !$acc   flow_w_n,  &
      !$acc   grid_sz   &
      !$acc )
      do s = grid_region_f_face(reg), grid_region_l_face(reg)
        c2 = grid_faces_c(2,s)  ! boundary cell
        flow_v_flux_n(s) = flow_u_n(c2) * grid_sx(s)  &
                             + flow_v_n(c2) * grid_sy(s)  &
                             + flow_w_n(c2) * grid_sz(s)
      end do
      !$acc end parallel  ! faces
    end if    ! boundary region type

  end do      ! regions

  !-------------------------------------------!
  !   Calcululate inflow and outflow volume   !
  !   flow rates and inlet and outlet areas   !
  !-------------------------------------------!
  vol_in   = 0.0
  vol_out  = 0.0
  area_in  = 0.0
  area_out = 0.0

  do reg = Boundary_Regions()
    if(Grid % region % type(reg) .eq. INFLOW) then

      !$acc parallel loop reduction(+: area_in,vol_in)  &
      !$acc present(  &
      !$acc   grid_region_f_face,  &
      !$acc   grid_region_l_face,  &
      !$acc   grid_s,  &
      !$acc   flow_v_flux_n   &
      !$acc )
      do s = grid_region_f_face(reg), grid_region_l_face(reg)
        area_in = area_in + grid_s(s)
        vol_in  = vol_in  - flow_v_flux_n(s)
      end do
      !$acc end parallel

    end if

    if(Grid % region % type(reg) .eq. PRESSURE .or.  &
       Grid % region % type(reg) .eq. OUTFLOW  .or.  &
       Grid % region % type(reg) .eq. CONVECT) then

      !$acc parallel loop reduction(+: area_out,vol_out)  &
      !$acc present(  &
      !$acc   grid_region_f_face,  &
      !$acc   grid_region_l_face,  &
      !$acc   grid_s,  &
      !$acc   flow_v_flux_n   &
      !$acc )
      do s = grid_region_f_face(reg), grid_region_l_face(reg)
        area_out = area_out + grid_s(s)
        vol_out  = vol_out  + flow_v_flux_n(s)
      end do
      !$acc end parallel

    end if
  end do

  call Global % Sum_Reals(vol_in,   &
                          vol_out,  &
                          area_in,  &
                          area_out)

  !-----------------------------------------------------------------!
  !   If there is volume imbalance in the source for the pressure   !
  !   (correction) equation, pressure will converge poorly, if at   !
  !   all. Thus, correct the outlet fluxes to enforce the balance   !
  !-----------------------------------------------------------------!

  if(.not. Math % Approx_Real(vol_in, vol_out, FEMTO)) then

    ! You should compute the "fac" now ...
    fac = vol_in / (vol_out + TINY)

    ! ... and correct all velocities
    vol_out = 0.0

    do reg = Boundary_Regions()
      if(Grid % region % type(reg) .eq. OUTFLOW   .or.  &
         Grid % region % type(reg) .eq. CONVECT   .or.  &
         Grid % region % type(reg) .eq. PRESSURE) then

        !$acc parallel loop reduction(+: vol_out)  &
        !$acc present(  &
        !$acc   grid_region_f_face,  &
        !$acc   grid_region_l_face,  &
        !$acc   grid_faces_c,  &
        !$acc   flow_u_n,  &
        !$acc   flow_v_n,  &
        !$acc   flow_w_n,  &
        !$acc   flow_v_flux_n,  &
        !$acc   grid_sx,  &
        !$acc   grid_sy,  &
        !$acc   grid_sz   &
        !$acc )
        do s = grid_region_f_face(reg), grid_region_l_face(reg)  ! all present
          c2 = grid_faces_c(2,s)

          ! Update velocity components ...
          flow_u_n(c2) = flow_u_n(c2) * fac
          flow_v_n(c2) = flow_v_n(c2) * fac
          flow_w_n(c2) = flow_w_n(c2) * fac

          ! ... volume flux itself ...
          flow_v_flux_n(s) = flow_u_n(c2) * grid_sx(s)    &
                               + flow_v_n(c2) * grid_sy(s)    &
                               + flow_w_n(c2) * grid_sz(s)

          ! ... and bulk volume out
          vol_out = vol_out + flow_v_flux_n(s)
        end do
        !$acc end parallel

      end if
    end do
  end if

  ! Holy mackrele: summ it up over all processors
  call Global % Sum_Real(vol_out)  ! not checked

  call Profiler % Stop('Balance_Volume')

  end subroutine
