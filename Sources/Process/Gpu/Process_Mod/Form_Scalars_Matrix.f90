!==============================================================================!
!   DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED FROM ITS FPP ORIGIN   !
!==============================================================================!

!==============================================================================!
  subroutine Form_Scalars_Matrix(Process, Grid, Flow, Turb,  &
                                 diff_eff, urf, dt)
!------------------------------------------------------------------------------!
  implicit none
!------------------------------------------------------------------------------!
  class(Process_Type)                   :: Process
  type(Grid_Type),   intent(in), target :: Grid
  type(Field_Type),              target :: Flow
  type(Turb_Type),               target :: Turb
  real                                  :: diff_eff(-Grid % n_bnd_cells &
                                                    :Grid % n_cells)
  real                                  :: urf
  real,    optional, intent(in)         :: dt       !! time step
!-----------------------------------[Locals]-----------------------------------!
  real,      contiguous, pointer :: val(:), fc(:)
  integer,   contiguous, pointer :: dia(:), pos(:,:)
  integer                        :: c, s, c1, c2, i_cel, reg, nz, i
  real                           :: a12, a21, fl, cfs
# if T_FLOWS_DEBUG == 1
  real, allocatable :: temp(:)
# endif
!------------------------[Avoid unused parent warning]-------------------------!
  Unused(Process)
!==============================================================================!

  call Profiler % Start('Form_Scalars_Matrix')

  !-----------------------!
  !   Take some aliases   !
  !-----------------------!
  val => Flow % Nat % A % val
  dia => Flow % Nat % C % dia
  pos => Flow % Nat % C % pos
  fc  => Flow % Nat % C % fc
  nz  =  Flow % Nat % C % nonzeros

  Assert(urf > 0.0)

  !-----------------------------------------------------------!
  !   Start by copying molecular viscosity to the effective   !
  !-----------------------------------------------------------!
  !$acc parallel loop independent  &
  !$acc present(  &
  !$acc   grid_region_f_cell,  &
  !$acc   grid_region_l_cell,  &
  !$acc   diff_eff,  &
  !$acc   flow_diffusivity   &
  !$acc )
  do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions+1)
    diff_eff(c) = flow_diffusivity(c)
  end do
  !$acc end parallel

  !---------------------------------------!
  !   Initialize matrix entries to zero   !
  !---------------------------------------!

  !$acc parallel loop independent  &
  !$acc present(  &
  !$acc   val   &
  !$acc )
  do i = 1, nz  ! all present
    val(i) = 0.0
  end do
  !$acc end parallel

  !--------------------------------------------------!
  !                                                  !
  !   Compute neighbouring coefficients over cells   !
  !                                                  !
  !--------------------------------------------------!

  !------------------------------------!
  !   Coefficients inside the domain   !
  !------------------------------------!

  !$acc parallel loop independent  &
  !$acc present(  &
  !$acc   grid_region_f_cell,  &
  !$acc   grid_region_l_cell,  &
  !$acc   grid_cells_n_cells,  &
  !$acc   grid_cells_c,  &
  !$acc   grid_cells_f,  &
  !$acc   diff_eff,  &
  !$acc   fc,  &
  !$acc   val,  &
  !$acc   pos,  &
  !$acc   dia   &
  !$acc )
  do c1 = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present

  !$acc loop seq
    do i_cel = 1, grid_cells_n_cells(c1)
      c2 = grid_cells_c(i_cel, c1)
      s  = grid_cells_f(i_cel, c1)

      if(c2 .gt. 0) then

        a12 = Face_Value(s, diff_eff(c1), diff_eff(c2)) * fc(s)
        a21 = a12

        if(c1 .lt. c2) then
          val(pos(1,s)) = -a12
          val(pos(2,s)) = -a21
        end if

        ! Update only diaginal at c1 to avoid race conditions
        val(dia(c1)) = val(dia(c1)) + a12

      end if
    end do
  !$acc end loop

  end do
  !$acc end parallel

  !---------------------------------------!
  !   Upwind blending inside the domain   !
  !---------------------------------------!
  if(Flow % t % blend_matrix) then

    !$acc parallel loop independent  &
    !$acc present(  &
    !$acc   grid_region_f_cell,  &
    !$acc   grid_region_l_cell,  &
    !$acc   grid_cells_n_cells,  &
    !$acc   grid_cells_c,  &
    !$acc   grid_cells_f,  &
    !$acc   flow_v_flux_n,  &
    !$acc   flow_density,  &
    !$acc   val,  &
    !$acc   pos,  &
    !$acc   dia   &
    !$acc )
    do c1 = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present

    !$acc loop seq
      do i_cel = 1, grid_cells_n_cells(c1)
        c2 = grid_cells_c(i_cel, c1)
        s  = grid_cells_f(i_cel, c1)
        fl = flow_v_flux_n(s)

        if(c2 .gt. 0) then

          cfs = Face_Value(s, flow_density(c1), flow_density(c2))
          a12 = 0.0
          a21 = 0.0

          if(c1 .lt. c2) then
            if(fl > 0.0) a21 = a21 + fl * cfs
            if(fl < 0.0) a12 = a12 - fl * cfs
            val(pos(1,s)) = val(pos(1,s)) - a12
            val(pos(2,s)) = val(pos(2,s)) - a21
          end if

          if(c1 .gt. c2) then
            if(fl > 0.0) a12 = a12 + fl * cfs
          end if

          ! Update only diaginal at c1 to avoid race conditions
          val(dia(c1)) = val(dia(c1)) + a12

        end if
      end do
    !$acc end loop

    end do
    !$acc end parallel

  end if

  !------------------------------------!
  !   Coefficients on the boundaries   !
  !------------------------------------!

  !$acc parallel loop  &
  !$acc present(  &
  !$acc   grid_region_f_face,  &
  !$acc   grid_region_l_face,  &
  !$acc   grid_faces_c,  &
  !$acc   phi_bnd_cond_type,  &
  !$acc   diff_eff,  &
  !$acc   fc,  &
  !$acc   val,  &
  !$acc   dia   &
  !$acc )
  do s = grid_region_f_face(1), grid_region_l_face(grid_n_bnd_regions)  ! all present
    c1 = grid_faces_c(1,s)    ! inside cell
    c2 = grid_faces_c(2,s)    ! boundary cell
    if(phi_bnd_cond_type(c2) .eq. WALL    .or.  &
       phi_bnd_cond_type(c2) .eq. INFLOW) then
      a12 = diff_eff(c1) * fc(s)
      val(dia(c1)) = val(dia(c1)) + a12
    end if
  end do
  !$acc end parallel

  !------------------------------------!
  !                                    !
  !   Take care of the unsteady term   !
  !                                    !
  !------------------------------------!
  if(present(dt)) then
    !$acc parallel loop independent  &
    !$acc present(  &
    !$acc   grid_region_f_cell,  &
    !$acc   grid_region_l_cell,  &
    !$acc   val,  &
    !$acc   dia,  &
    !$acc   flow_density,  &
    !$acc   grid_vol   &
    !$acc )
    do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present, was independent
      val(dia(c)) = val(dia(c)) + flow_density(c) * grid_vol(c) / dt
    end do
    !$acc end parallel
  end if

  call Profiler % Stop('Form_Scalars_Matrix')

  end subroutine
