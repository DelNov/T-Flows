!==============================================================================!
!   DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED FROM ITS FPP ORIGIN   !
!==============================================================================!

!==============================================================================!
  subroutine Compute_Pressure(Process, Grid, Flow)
!------------------------------------------------------------------------------!
  implicit none
!------------------------------------------------------------------------------!
  class(Process_Type)      :: Process
  type(Grid_Type),  target :: Grid
  type(Field_Type), target :: Flow
!-----------------------------------[Locals]-----------------------------------!
  real,    contiguous, pointer :: val(:)
  real,    contiguous, pointer :: b(:)
  integer, contiguous, pointer :: row(:), col(:)
  real                         :: urf, p_max, p_min
  integer                      :: c
!------------------------[Avoid unused parent warning]-------------------------!
  Unused(Process)
!==============================================================================!

  call Profiler % Start('Compute_Pressure')

  ! Take some aliases
  val => Flow % Nat % A % val
  row => Flow % Nat % A % row
  col => Flow % Nat % A % col
  b   => Flow % Nat % b
  urf =  Flow % pp % urf

  !-----------------------------------------------!
  !   Discretize the pressure Poisson equations   !
  !-----------------------------------------------!
  call Process % Form_Pressure_Matrix(Flow, Grid)

  !---------------------------------------------------------------!
  !   Insert proper source (volume source) to pressure equation   !
  !---------------------------------------------------------------!
  call Process % Insert_Volume_Source_For_Pressure(Flow, Grid)

# if T_FLOWS_DEBUG == 1
    call Grid % Save_Debug_Vtu("bp_0",                &
                               inside_name="vol_src", &
                               inside_cell=b)
# endif

  !------------------------!
  !   Call linear solver   !
  !------------------------!
  if(Flow % pp % solver .eq. 'cg') then
    call Profiler % Start('CG_for_Pressure')
    call Flow % Nat % Cg(Flow % pp % n,                         &
                         Flow % pp % miter, Flow % pp % niter,  &
                         Flow % pp % tol,   Flow % pp % res)
    call Profiler % Stop('CG_for_Pressure')
  else if(Flow % pp % solver .eq. 'rs_amg') then
    call Profiler % Start('AMG_for_Pressure')
    call Amg % Amg1r5(val,              &
                      row,              &
                      col,              &
                      Flow % pp % n(1:Grid % n_cells),                 &
                      b(1:Grid % n_cells),                                &
                      Grid % n_cells,  &
                      4)
    Flow % pp % res   = Amg % Final_Residual()
    Flow % pp % niter = Amg % Performed_Cycles()
    call Profiler % Stop('AMG_for_Pressure')
  end if

  call Info % Iter_Fill_At(1, 4, Flow % pp % name,  &
                                 Flow % pp % res, Flow % pp % niter)

  !-------------------------------!
  !   Update the pressure field   !
  !-------------------------------!

  !$acc parallel loop independent  &
  !$acc present(  &
  !$acc   grid_region_f_cell,  &
  !$acc   grid_region_l_cell,  &
  !$acc   flow_p_n,  &
  !$acc   flow_pp_n   &
  !$acc )
  do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present
    flow_p_n(c) = flow_p_n(c) + urf * flow_pp_n(c)
  end do
  !$acc end parallel

  !---------------------------------------------------------------!
  !   Shift the pressure field so that the median value is zero   !
  !---------------------------------------------------------------!
  p_max = -HUGE
  p_min = +HUGE

  !$acc parallel loop independent reduction(max: p_max) reduction(min: p_min)  &
  !$acc present(  &
  !$acc   grid_region_f_cell,  &
  !$acc   grid_region_l_cell,  &
  !$acc   flow_p_n   &
  !$acc )
  do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present
    p_max = max(p_max, flow_p_n(c))
    p_min = min(p_min, flow_p_n(c))
  end do
  !$acc end parallel

  call Global % Max_Real(p_max)
  call Global % Min_Real(p_min)

  !$acc parallel loop independent  &
  !$acc present(  &
  !$acc   grid_region_f_cell,  &
  !$acc   grid_region_l_cell,  &
  !$acc   flow_p_n   &
  !$acc )
  do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present
    flow_p_n(c) = flow_p_n(c) - 0.5 * (p_max + p_min)
  end do
  !$acc end parallel

  ! Update buffers for presssure over all processors
  call Grid % Exchange_Cells_Real(Flow % p % n)

# if T_FLOWS_DEBUG == 1
    call Grid % Save_Debug_Vtu("pp_0",           &
                               scalar_name="pp", &
                               scalar_cell=Flow % pp % n)
    call Grid % Save_Debug_Vtu("p_0",            &
                               scalar_name="p",  &
                               scalar_cell=Flow % p % n)
# endif

  call Profiler % Stop('Compute_Pressure')

  end subroutine
