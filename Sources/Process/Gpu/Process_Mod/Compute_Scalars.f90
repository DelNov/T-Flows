!==============================================================================!
!   DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED FROM ITS FPP ORIGIN   !
!==============================================================================!

!==============================================================================!
  subroutine Compute_Scalars(Process, Grid, Flow, Turb)
!------------------------------------------------------------------------------!
  implicit none
!------------------------------------------------------------------------------!
  class(Process_Type)      :: Process
  type(Grid_Type),  target :: Grid
  type(Field_Type), target :: Flow
  type(Turb_Type),  target :: Turb
!-----------------------------------[Locals]-----------------------------------!
  type(Var_Type),        pointer :: phi
  real,      contiguous, pointer :: val(:)
  integer,   contiguous, pointer :: dia(:)
  real,      contiguous, pointer :: b(:), diff_eff(:)
  real                           :: urf, rs
  integer                        :: c, sc, row, col
!------------------------[Avoid unused parent warning]-------------------------!
  Unused(Process)
!==============================================================================!

  call Profiler % Start('Compute_Scalars')

  call Work % Connect_Real_Cell(diff_eff)

  !------------------------------------------------------------!
  !   First take some aliases, which is quite elaborate here   !
  !------------------------------------------------------------!
  val => Flow % Nat % A % val
  dia => Flow % Nat % C % dia
  b   => Flow % Nat % b

  !--------------------------------!
  !                                !
  !   Browse through all scalars   !
  !                                !
  !--------------------------------!
  do sc = 1, Flow % n_scalars

    !-------------------------------------------------!
    !   Important: take the alias of current scalar   !
    !-------------------------------------------------!
    phi               => Flow % scalar(sc)
    phi_bnd_cond_type => Flow % scalar(sc) % bnd_cond_type

    ! Tolerances and under-relaxations are the same for all components
    urf = phi % urf

    !---------------------------------------------------!
    !   Update old values (o) and older than old (oo)   !
    !---------------------------------------------------!
    if(Iter % Current() .eq. 1) then

      if(phi % td_scheme .eq. PARABOLIC) then
        phi_oo => phi % oo
        phi_o => phi % o
        !$acc parallel loop independent  &
        !$acc present(  &
        !$acc   grid_region_f_cell,  &
        !$acc   grid_region_l_cell,  &
        !$acc   phi_oo,  &
        !$acc   phi_o   &
        !$acc )
        do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions+1)  ! all present
          phi_oo(c) = phi_o(c)
        end do
        !$acc end parallel
      end if

      phi_o => phi % o
      phi_n => phi % n
      !$acc parallel loop independent  &
      !$acc present(  &
      !$acc   grid_region_f_cell,  &
      !$acc   grid_region_l_cell,  &
      !$acc   phi_o,  &
      !$acc   phi_n   &
      !$acc )
      do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions+1) !all present
        phi_o(c) = phi_n(c)
      end do
      !$acc end parallel

    end if

    !-------------------------------------------------!
    !   Discretize the scalar conservation equation   !
    !-------------------------------------------------!
    call Process % Form_Scalars_Matrix(Grid, Flow, Turb, diff_eff,  &
                                       urf, dt=Flow % dt)

    !-----------------------------------------------------------!
    !   Insert proper sources (forces) to transport equations   !
    !-----------------------------------------------------------!

    ! From boundary conditions
    call Process % Insert_Scalars_Bc(Grid, Flow, sc)

    ! Inertial and advection terms
    call Flow % Add_Inertial_Term (Grid, phi, Flow % density)
    call Flow % Add_Advection_Term(Grid, phi, Flow % density)

    ! Insert cross diffusion terms (computers gradients as well)
    call Flow % Add_Cross_Diffusion_Term(Grid, phi, diff_eff)

    !------------------------------!
    !   Perform under-relaxation   !
    !------------------------------!
    phi_n => phi % n
    !$acc parallel loop independent  &
    !$acc present(  &
    !$acc   grid_region_f_cell,  &
    !$acc   grid_region_l_cell,  &
    !$acc   val,  &
    !$acc   dia,  &
    !$acc   b,  &
    !$acc   phi_n   &
    !$acc )
    do c = grid_region_f_cell(grid_n_regions), grid_region_l_cell(grid_n_regions)  ! all present
      val(dia(c)) = val(dia(c)) / urf
      b(c) = b(c) + val(dia(c)) * (1.0 - urf) * phi_n(c)
    end do
    !$acc end parallel

    !------------------------!
    !   Call linear solver   !
    !------------------------!
    call Profiler % Start('CG_for_Scalars')
    call Flow % Nat % Cg(phi % n,     &
                         phi % miter, &
                         phi % niter, &
                         phi % tol,   &
                         phi % res)
    call Profiler % Stop('CG_for_Scalars')

# if T_FLOWS_DEBUG == 1
    call Grid % Save_Debug_Vtu("C_00",           &
                               scalar_name="C_00", &
                               scalar_cell=phi)
# endif

    rs = sc                      ! reterive the rank of scalar
    row = ceiling(rs/6) + 1      ! will be 1 (scal. 1-6), 2 (scal. 6-12), etc.
    col = nint(rs) - (row-1)*6   ! will be in range 1 - 6
    row = (sc-1)/6 + 1           ! will be 1 (scal. 1-6), 2 (scal. 6-12), etc.
    col = mod(sc-1, 6) + 1       ! will be in range 1 - 6

    call Info % Iter_Fill_Scalar_At(row, col, phi % name,  &
                                              phi % res,   &
                                              phi % niter)
  end do  ! through scalars

  call Work % Disconnect_Real_Cell(diff_eff)

  call Profiler % Stop('Compute_Scalars')

  end subroutine
