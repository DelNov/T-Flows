!==============================================================================!
  subroutine Backup_Mod_Read_Face(grid, flux, fh, d)
!------------------------------------------------------------------------------!
!   Reads face-based variable (flux) using cell-based arrays.                  !
!------------------------------------------------------------------------------!
!----------------------------------[Modules]-----------------------------------!
  use Grid_Mod
  use Comm_Mod
!------------------------------------------------------------------------------!
  implicit none
!---------------------------------[Arguments]----------------------------------!
  type(Grid_Type) :: grid
  real            :: flux(grid % n_faces)
  integer         :: fh, d
!-----------------------------------[Locals]-----------------------------------!
  integer              :: s, c, c1, c2, cm1, cm2, mc, max_cnt
  integer, allocatable :: cell_map(:)
  integer, allocatable :: face_cnt(:)
  integer, allocatable :: face_pnt(:,:)
  integer, allocatable :: face_sgn(:,:)
  real,    allocatable :: cell_flx(:)
  character(len=12)    :: cf_name = 'cell_flux_00'
!==============================================================================!

  allocate(cell_map(-grid % n_bnd_cells : grid % n_cells));  cell_map = 0
  allocate(face_cnt(    grid % n_cells));                    face_cnt = 0
  allocate(face_pnt(24, grid % n_cells));                    face_pnt = 0
  allocate(face_sgn(24, grid % n_cells));                    face_sgn = 1
  allocate(cell_flx(    grid % n_cells));                    cell_flx = 0.0

  ! Create local cell mapping (from 1) 
  do c = 1, grid % n_cells
    cell_map(c) = grid % comm % cell_map(c) + 1  ! from C to Fortran mapping
  end do
  call Comm_Mod_Exchange_Int(grid, cell_map)

  ! Browse through all faces
  do s = 1, grid % n_faces
    c1 = grid % faces_c(1, s)
    c2 = grid % faces_c(2, s)

    ! Take cells' global numbers (it will be zero for boundary cells)
    cm1 = cell_map(c1)
    cm2 = cell_map(c2)

    face_cnt(c1) = face_cnt(c1) + 1
    face_pnt(face_cnt(c1), c1) = s

    ! Correct the sign if necessary
    face_sgn(face_cnt(c1), c1) = +1
    if(cm2 > cm1) then
      face_sgn(face_cnt(c1), c1) = -1
    end if
  end do

  ! Find maximum number of stored faces per cell
  max_cnt = 0
  do c = 1, grid % n_cells
    if( face_cnt(c) > max_cnt ) max_cnt = face_cnt(c)
  end do
  call Comm_Mod_Global_Max_Int(max_cnt)

  do mc = 1, max_cnt
    cell_flx = 0.0
    write(cf_name(11:12), '(i2.2)'), mc
    call Backup_Mod_Read_Cell(fh, d, cf_name, cell_flx(1:nc_s))
    do c = 1, grid % n_cells
      if( face_pnt(mc, c) .ne. 0 ) then
        flux( face_pnt(mc, c) ) = cell_flx(c)
      end if
    end do
  end do

  deallocate(cell_map)
  deallocate(face_cnt)
  deallocate(face_pnt)
  deallocate(face_sgn)
  deallocate(cell_flx)

  return

  end subroutine
