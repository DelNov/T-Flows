/*********************************************************************
 *
 *  Utopian city mesh
 *
 *********************************************************************/

//------------------------------------------------------------------------------
//
// Parameters defining domain extents, buildings and mesh resolution
// (This should be fiddled with, but with care)
//
//------------------------------------------------------------------------------

NUMBER_OF_BUILDINGS =   0;                // number of buildings
NUMBER_OF_LAYERS    =  60;                // number of mesh layers in height
SKY_HIGH            =   1.0;              // height of the domain

// Coordinates of the problem domain (the whole piece of simulated land)
GROUND_X_MIN = -2.0;
GROUND_X_MAX =  3.0;
GROUND_Y_MIN = -1.5;
GROUND_Y_MAX =  1.5;

// Coordinates of the city (where buildings will reside)
CITY_X_MIN = -1.2;
CITY_X_MAX =  1.0;
CITY_Y_MIN = -0.8;
CITY_Y_MAX =  0.8;

// Transition between fine and coarse mesh, ...
// ... between city and the rest of the domain
DELTA_MIN = 0.02;  // resolution in the city
DELTA_MAX = 0.22;  // resolution in the country side
TW = 0.11;

//------------------------------------------------------------------------------
//
// Parameters for the problem definition algorithms
// (These are better kept untouched)
//
//------------------------------------------------------------------------------
GROUND_LOOP         = 100;                // ground loop number
HOLE_LOOP_START     = GROUND_LOOP + 100;  // hole definitions
BASE_LOOP_START     = GROUND_LOOP + 200;  // buildings' base definitions
GROUND_SURF         = 100;                // ground surface number
MAX_BUILDING_HEIGHT = 300;
MAXN                =   8;                // max nodes per building
TINY                =   1.0e-9;
HUGE                =   1.0e+9;

//------------------------------------------------------------
// Points and lines defining the extents of the ground domain
//------------------------------------------------------------
Point(1) = {GROUND_X_MIN, GROUND_Y_MIN, 0};
Point(2) = {GROUND_X_MAX, GROUND_Y_MIN, 0};
Point(3) = {GROUND_X_MAX, GROUND_Y_MAX, 0};
Point(4) = {GROUND_X_MIN, GROUND_Y_MAX, 0};
Line(1) = {1, 2};
Line(2) = {2, 3};
Line(3) = {3, 4};
Line(4) = {4, 1};
Curve Loop(GROUND_LOOP) = {1, 2, 3, 4};

//---------------------------------
// Define all buildings' positions
//---------------------------------

b = 1;
node_b(b) = 4;
x(MAXN*b + 1) =  0.0;   y(MAXN*b + 1) = 0.1;
x(MAXN*b + 2) =  0.2;   y(MAXN*b + 2) = 0.1;
x(MAXN*b + 3) =  0.1;   y(MAXN*b + 3) = 0.4;
x(MAXN*b + 4) =  0.0;   y(MAXN*b + 4) = 0.4;
height_b(b) = 280;

b = 2;
node_b(b) = 3;
x(MAXN*b + 1) = -0.70;  y(MAXN*b + 1) = -0.10;
x(MAXN*b + 2) = -0.50;  y(MAXN*b + 2) = -0.30;
x(MAXN*b + 3) = -0.45;  y(MAXN*b + 3) = -0.05;
height_b(b) = 200;

b = 3;
node_b(b) = 6;
x(MAXN*b + 1) = -0.10;  y(MAXN*b + 1) = -0.40;
x(MAXN*b + 2) =  0.10;  y(MAXN*b + 2) = -0.40;
x(MAXN*b + 3) =  0.10;  y(MAXN*b + 3) = -0.30;
x(MAXN*b + 4) =  0.00;  y(MAXN*b + 4) = -0.30;
x(MAXN*b + 5) =  0.00;  y(MAXN*b + 5) = -0.10;
x(MAXN*b + 6) = -0.10;  y(MAXN*b + 6) = -0.10;
height_b(b) = 120;

b = 4;
node_b(b) = 6;
x(MAXN*b + 1) =  0.28;  y(MAXN*b + 1) = -0.40;
x(MAXN*b + 2) =  0.48;  y(MAXN*b + 2) = -0.40;
x(MAXN*b + 3) =  0.48;  y(MAXN*b + 3) = -0.30;
x(MAXN*b + 4) =  0.38;  y(MAXN*b + 4) = -0.30;
x(MAXN*b + 5) =  0.38;  y(MAXN*b + 5) = -0.10;
x(MAXN*b + 6) =  0.28;  y(MAXN*b + 6) = -0.10;
height_b(b) = 120;

b = 5;
node_b(b) = 4;
x(MAXN*b + 1) = -0.70;  y(MAXN*b + 1) = 0.20;
x(MAXN*b + 2) = -0.55;  y(MAXN*b + 2) = 0.20;
x(MAXN*b + 3) = -0.55;  y(MAXN*b + 3) = 0.30;
x(MAXN*b + 4) = -0.70;  y(MAXN*b + 4) = 0.30;
height_b(b) =  60;

b = 6;
node_b(b) = 4;
x(MAXN*b + 1) = -0.40;  y(MAXN*b + 1) = 0.20;
x(MAXN*b + 2) = -0.25;  y(MAXN*b + 2) = 0.20;
x(MAXN*b + 3) = -0.25;  y(MAXN*b + 3) = 0.30;
x(MAXN*b + 4) = -0.40;  y(MAXN*b + 4) = 0.30;
height_b(b) =  60;

b = 7;
node_b(b) = 4;
x(MAXN*b + 1) = -0.70;  y(MAXN*b + 1) = 0.40;
x(MAXN*b + 2) = -0.55;  y(MAXN*b + 2) = 0.40;
x(MAXN*b + 3) = -0.55;  y(MAXN*b + 3) = 0.50;
x(MAXN*b + 4) = -0.70;  y(MAXN*b + 4) = 0.50;
height_b(b) =  80;

b = 8;
node_b(b) = 4;
x(MAXN*b + 1) = -0.40;  y(MAXN*b + 1) = 0.40;
x(MAXN*b + 2) = -0.25;  y(MAXN*b + 2) = 0.40;
x(MAXN*b + 3) = -0.25;  y(MAXN*b + 3) = 0.50;
x(MAXN*b + 4) = -0.40;  y(MAXN*b + 4) = 0.50;
height_b(b) =  80;

//-----------------------------------------------------------------------
// Browse through all buildings to define points and lines defining them
//-----------------------------------------------------------------------
For b In {1:NUMBER_OF_BUILDINGS}

  // Browse through nodes of the building "b"
  For n In{ 1 : node_b(b) }
    Point(MAXN*b + n) = {x(MAXN*b + n), y(MAXN*b + n), 0};
  EndFor

  // Lines defining the building
  For n In{ 1 : node_b(b)-1 }
    Line(MAXN*b + n) = {MAXN*b + n, MAXN*b + n + 1};
  EndFor
  Line(MAXN*b + node_b(b)) = {MAXN*b + node_b(b), MAXN*b + 1};

  // Anticlockwise curves (holes)
  Curve Loop(HOLE_LOOP_START + b) = {MAXN*b + 1 : MAXN*b + node_b(b)};

  // Clockwise curves (buidlings' bases)
  Curve Loop(BASE_LOOP_START + b) = {MAXN*b + 1 : MAXN*b + node_b(b)};
EndFor

//------------------------------------------------------------------------------
//
// Define surfaces
//
//------------------------------------------------------------------------------

//----------------------------------------
// Define ground surface witout buildings
//----------------------------------------
If(NUMBER_OF_BUILDINGS > 0)
  Plane Surface(GROUND_SURF) = {GROUND_LOOP,
                                HOLE_LOOP_START + 1:
                                HOLE_LOOP_START + NUMBER_OF_BUILDINGS};
Else
  Plane Surface(GROUND_SURF) = {GROUND_LOOP};
EndIf
Printf("Defined ground surface %g", GROUND_SURF);

//-----------------------------------
// Add individual buildings surfaces
//-----------------------------------
For b In {1:NUMBER_OF_BUILDINGS}
  Plane Surface(GROUND_SURF + b) = {BASE_LOOP_START + b};
  Printf("Defined building surface %g", GROUND_SURF + b);
EndFor

//------------------------------------------------------------------------------
//
// Define mesh
//
//------------------------------------------------------------------------------

//------------------------
// First spacing function
//------------------------
Field[1] = MathEval;
Field[1].F = Sprintf("  (%5.2g)
                      + (%5.2g) * (1.0-(0.5*(  tanh((x-(%5.2g))/(%5.2g))
                                             - tanh((x-(%5.2g))/(%5.2g))))
                                      *(0.5*(  tanh((y-(%5.2g))/(%5.2g))
                                             - tanh((y-(%5.2g))/(%5.2g)))) )",
  DELTA_MIN,
  DELTA_MAX - DELTA_MIN,
  CITY_X_MIN, TW,
  CITY_X_MAX, TW,
  CITY_Y_MIN, TW,
  CITY_Y_MAX, TW);
Background Field = 1;

//---------------------------------------------------
// Generate mesh on the ground, and on all the bases
//---------------------------------------------------
Recombine Surface{GROUND_SURF};
For b In {1:NUMBER_OF_BUILDINGS}
  Recombine Surface{GROUND_SURF + b};
EndFor

// This experimental algorithm could give better results
Mesh.Algorithm = 8;

// Uncomment the following line to try the full-quad algorithm:
// Mesh.RecombinationAlgorithm = 2; // or 3

//---------------
// Create volume
//---------------
Extrude {0, 0, SKY_HIGH} {
  Surface{GROUND_SURF : GROUND_SURF + NUMBER_OF_BUILDINGS};
  Layers{NUMBER_OF_LAYERS};
  Recombine;
}

//------------------------------------------------------------------------------
//
// Define boundary conditions
//
//------------------------------------------------------------------------------

//--------
// Ground
//--------
Physical Surface("ground") = {GROUND_SURF};

//-----------
// Buildings
//-----------

For h In {0:MAX_BUILDING_HEIGHT}     // browse through all heights
  exists = 0;

  For b In {1:NUMBER_OF_BUILDINGS}   // browse through all buildings

    // Add the buildings whose height matches "h"
    If(height_b(b) == h)  // found a building with matching height
      If(exists == 0)     // is it the first building at this height
        exists = 1;       // not any more
        Physical Surface(Sprintf("building_%03g", h)) = {GROUND_SURF + b};
      Else                // not the first building at this height, append
        Physical Surface(Sprintf("building_%03g", h)) += {GROUND_SURF + b};
      EndIf
    EndIf

  EndFor
EndFor

//---------------------------------------------
// East, west, south, north and eventually top
//---------------------------------------------
Physical Surface("east")
  = {Surface In BoundingBox{GROUND_X_MIN-TINY, -HUGE, -HUGE,
                            GROUND_X_MIN+TINY, +HUGE, +HUGE}};
Physical Surface("west")
  = {Surface In BoundingBox{GROUND_X_MAX-TINY, -HUGE, -HUGE,
                            GROUND_X_MAX+TINY, +HUGE, +HUGE}};
Physical Surface("south")
  = {Surface In BoundingBox{-HUGE, GROUND_Y_MIN-TINY, -HUGE,
                            +HUGE, GROUND_Y_MIN+TINY, +HUGE}};
Physical Surface("north")
  = {Surface In BoundingBox{-HUGE, GROUND_Y_MAX-TINY, -HUGE,
                            +HUGE, GROUND_Y_MAX+TINY, +HUGE}};
Physical Surface("top") 
  = {Surface In BoundingBox{-HUGE, -HUGE, SKY_HIGH-TINY,
                            +HUGE, +HUGE, SKY_HIGH+TINY}};

//------------------------------------------------------------------------------
//
// Create pysical volume
//
//------------------------------------------------------------------------------
Physical Volume("interior") = {1:1+NUMBER_OF_BUILDINGS};
